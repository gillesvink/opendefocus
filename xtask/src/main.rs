mod license;
mod nuke;
mod precommit;
mod test;
mod util;
use core::fmt;
use std::path::PathBuf;

use crate::{
    license::fetch_licenses,
    nuke::{compile_nuke, create_package},
    precommit::precommit,
    test::{test_crates, test_nuke_plugin_package},
    util::crate_root,
};
use anyhow::{Error, Result};
use clap::{ArgAction, Parser};
use duct::cmd;
use naga::{back::wgsl::WriterFlags, front::spv::Options};

#[derive(clap::ValueEnum, Clone, Copy, Debug, PartialEq)]
pub enum TargetPlatform {
    Windows,
    Linux,
    MacosX86_64,
    MacosAarch64,
}

impl fmt::Display for TargetPlatform {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TargetPlatform::Windows => write!(f, "x86_64-windows"),
            TargetPlatform::Linux => write!(f, "x86_64-linux"),
            TargetPlatform::MacosX86_64 => write!(f, "x86_64-macos"),
            TargetPlatform::MacosAarch64 => write!(f, "aarch64-macos"),
        }
    }
}

#[derive(Parser, Debug)]
#[command(version, about, long_about = None, arg_required_else_help = true)]
struct Args {
    #[clap(short, long, action=ArgAction::SetTrue)]
    compile: bool,
    /// If compilation of spirv is needed
    #[clap(short, long, action=ArgAction::SetTrue)]
    gpu: bool,

    #[clap(short, long)]
    target_platform: Option<TargetPlatform>,

    #[clap(short, long, value_delimiter = ',')]
    nuke_versions: Vec<String>,

    #[clap(long, action=ArgAction::SetTrue)]
    output_to_package: bool,

    #[clap(long)]
    create_licenses: Option<PathBuf>,

    #[clap(long, action=ArgAction::SetTrue)]
    serve_docs: bool,

    #[clap(long, action=ArgAction::SetTrue)]
    test_crates: bool,

    #[clap(long, action=ArgAction::SetTrue)]
    pytest: bool,

    #[clap(long, action=ArgAction::SetTrue)]
    test_nuke_plugin_package: bool,

    #[clap(long, action=ArgAction::SetTrue)]
    precommit: bool,
    
    #[arg(long)]
    args: bool,

    remaining: Vec<String>,
}

async fn compile_spirv() -> Result<()> {
    log::info!("Starting spirv build");
    let spirv_path = cmd!(
        "cargo",
        "+nightly-2025-06-30",
        "run",
        "--manifest-path",
        crate_root()
            .join("crates")
            .join("spirv-cli-build")
            .join("Cargo.toml"),
        "--release",
        "--",
        "-c",
        crate_root().join("crates").join("opendefocus-kernel"),
        "-o",
        "./",
        "--print-output",
    )
    .read()?
    .lines()
    .last()
    .ok_or(Error::msg("Command did not have a last line."))?
    .to_string();

    log::info!("Spirv shader compiled to {spirv_path}");

    let module =
        naga::front::spv::parse_u8_slice(&tokio::fs::read(spirv_path).await?, &Options::default())?;
    let module_info: naga::valid::ModuleInfo = naga::valid::Validator::new(
        naga::valid::ValidationFlags::all(),
        naga::valid::Capabilities::all(),
    )
    .subgroup_stages(naga::valid::ShaderStages::all())
    .subgroup_operations(naga::valid::SubgroupOperationSet::all())
    .validate(&module)?;
    let wgsl = naga::back::wgsl::write_string(&module, &module_info, WriterFlags::empty())?;
    let wgsl = format!(
        "// This file is automatically generated by xtask. Do not modify manually.\n// License: https://opendefocus.codeberg.page/license.html\n// Automatic spirv generation by Rust-GPU https://github.com/rust-gpu/rust-gpu\n\n{wgsl}"
    );
    tokio::fs::write(
        crate_root().join("shaders").join("opendefocus-kernel.wgsl"),
        wgsl,
    )
    .await?;
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .compact()
        .with_line_number(false)
        .with_file(false)
        .init();
    let args = Args::parse();

    if args.test_crates {
        test_crates().await?;
    }

    if args.pytest {
        if args.test_nuke_plugin_package {
            test_nuke_plugin_package().await?;
        }
    }

    if args.precommit {
        precommit()?;
    }

    if args.compile {
        if args.gpu {
            compile_spirv().await?;
        }
        if !args.nuke_versions.is_empty()
            && let Some(target_platform) = args.target_platform
        {
            compile_nuke(args.nuke_versions.clone(), target_platform).await?;
        }
    }
    if args.output_to_package
        && let Some(target_platform) = args.target_platform
    {
        create_package(target_platform, args.nuke_versions).await?;
    }

    if let Some(licenses_path) = args.create_licenses {
        fetch_licenses(licenses_path).await?;
    }

    if args.serve_docs {
        cmd!("mdbook", "serve", crate_root().join("docs")).run()?;
    }

    Ok(())
}
